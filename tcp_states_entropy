#!/usr/bin/env python3
from bcc import BPF
import time
import signal
import sys
import math
from datetime import datetime
import ctypes

# BPFç¨‹åº
prog = '''
#include <uapi/linux/ptrace.h>
#include <net/sock.h>
#include <linux/tcp.h>

// TCPçŠ¶æ€è®¡æ•°å™¨
BPF_ARRAY(tcp_state_counter, u64, 12);

int kprobe_tcp_set_state(struct pt_regs *ctx)
{
    struct sock *sk = (struct sock *)PT_REGS_PARM1(ctx);
    int new_state = (int)PT_REGS_PARM2(ctx);

    if (new_state < 0 || new_state >= 12)
        return 0;

    u32 key = new_state;
    u64 *count = tcp_state_counter.lookup(&key);
    if (count)
        __sync_fetch_and_add(count, 1);

    return 0;
}
'''

# TCPçŠ¶æ€åç§°
tcp_states = [
    "TCP_ESTABLISHED",
    "TCP_SYN_SENT", 
    "TCP_SYN_RECV",
    "TCP_FIN_WAIT1",
    "TCP_FIN_WAIT2",
    "TCP_TIME_WAIT",
    "TCP_CLOSE",
    "TCP_CLOSE_WAIT",
    "TCP_LAST_ACK",
    "TCP_LISTEN",
    "TCP_CLOSING",
    "TCP_NEW_SYN_RECV"
]

# å…¨å±€å˜é‡æ§åˆ¶ç¨‹åºé€€å‡º
exiting = False

def compute_entropy(state_counts):
    """è®¡ç®—ç†µå€¼"""
    total = sum(state_counts)
    if total == 0:
        return 0.0
    
    entropy = 0.0
    for count_val in state_counts:
        if count_val == 0:
            continue
        p = count_val / total
        entropy -= p * math.log2(p)
    
    return entropy

def reset_counters(b):
    """é‡ç½®æ‰€æœ‰è®¡æ•°å™¨ - ä½¿ç”¨ctypesç¡®ä¿çœŸæ­£æ¸…ç©º"""
    tcp_state_counter = b.get_table("tcp_state_counter")
    for i in range(12):
        # ä½¿ç”¨ctypes.c_uint64(0)è€Œä¸æ˜¯ç›´æ¥èµ‹å€¼0
        tcp_state_counter[ctypes.c_uint32(i)] = ctypes.c_uint64(0)
    print(f"ğŸ”„ Map cleared at {datetime.now().strftime('%H:%M:%S')}")

def sig_handler(signum, frame):
    """ä¿¡å·å¤„ç†å‡½æ•°"""
    global exiting
    exiting = True

def main():
    global exiting
    
    # è®¾ç½®ä¿¡å·å¤„ç†
    signal.signal(signal.SIGINT, sig_handler)
    signal.signal(signal.SIGTERM, sig_handler)
    
    # ç¼–è¯‘å¹¶åŠ è½½BPFç¨‹åº
    try:
        b = BPF(text=prog)
        b.attach_kprobe(event="tcp_set_state", fn_name="kprobe_tcp_set_state")
        
        print("Monitoring TCP states (5s sliding window), press Ctrl+C to exit")
        print("=" * 60)
        
        # æ—¶é—´çª—å£æ§åˆ¶
        window_duration = 5  # 5ç§’çª—å£
        last_reset_time = time.time()
        window_count = 0
        
        while not exiting:
            current_time = time.time()
            
            # æ£€æŸ¥æ˜¯å¦éœ€è¦é‡ç½®è®¡æ•°å™¨
            if current_time - last_reset_time >= window_duration:
                window_count += 1
                
                # è·å–å½“å‰çª—å£æ•°æ®
                state_counts = []
                tcp_state_counter = b.get_table("tcp_state_counter")
                for i in range(12):
                    try:
                        count = tcp_state_counter[ctypes.c_uint32(i)].value
                        state_counts.append(count)
                    except KeyError:
                        state_counts.append(0)
                
                # æ˜¾ç¤ºå½“å‰çª—å£ç»Ÿè®¡
                total_transitions = sum(state_counts)
                entropy = compute_entropy(state_counts)
                
                print(f"\nğŸ“Š Window #{window_count} - {datetime.now().strftime('%H:%M:%S')}")
                print(f"Duration: {window_duration}s | Total Transitions: {total_transitions} | Entropy: {entropy:.4f}")
                print("-" * 60)
                
                # æ˜¾ç¤ºéé›¶çŠ¶æ€
                active_states = []
                for i, count in enumerate(state_counts):
                    if count > 0:
                        percentage = (count / total_transitions * 100) if total_transitions > 0 else 0
                        active_states.append((tcp_states[i], count, percentage))
                
                if active_states:
                    print("Active TCP States:")
                    for state_name, count, percentage in active_states:
                        bar = "â–ˆ" * int(percentage / 2)  # ç®€å•çš„è¿›åº¦æ¡
                        print(f"  {state_name:<15} : {count:>6} ({percentage:>5.1f}%) {bar}")
                else:
                    print("No TCP state transitions in this window")
                
                print("=" * 60)
                
                # ğŸ”¥ é‡ç½®è®¡æ•°å™¨ - ä½¿ç”¨ctypesç¡®ä¿Mapè¢«æ¸…ç©º
                reset_counters(b)
                last_reset_time = current_time
                
                # éªŒè¯æ¸…ç©ºæ˜¯å¦æˆåŠŸ
                print("Verifying map reset...")
                for i in range(12):
                    try:
                        count = tcp_state_counter[ctypes.c_uint32(i)].value
                        if count != 0:
                            print(f"âš ï¸  Warning: {tcp_states[i]} still has count {count}")
                    except:
                        pass
                print("âœ… Map reset verification complete")
                
            time.sleep(0.1)  # çŸ­æš‚ç¡çœ ä»¥é¿å…è¿‡åº¦å ç”¨CPU
            
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    
    print("\nExiting...")

if __name__ == "__main__":
    main()
